#!/usr/bin/env ruby
#
# Once-only  Run applications once with the same inputs
# Author:: Pjotr Prins
# Copyright:: 2013

USAGE =<<EOB

once-only runs a command once only when inputs don't change!

Usage:

   -d path             change to directory before executing
   --copy              copy files to hash dir first
   --pbs [opts]        convert to PBS command with optional options
   --skip|--out file   skip making a checksum of the named file (multiple allowed)
   --skip-exe          skip making a checksum of the executable command/script
   --skip-cli          skip making a checksum of full command line
   --skip-regex regex  skip making checksumes of filenames that match the regex (multiple allowed)
   --skip-glob regex   skip making checksumes of filenames that match the glob (multiple allowed)
   --include|--in file include input filename for making the checksumes
   -v                  increase verbosity
   -q                  run quietly
   --debug             give debug information
   --dry-run           do not execute command
   --force             force execute command

Examples:

   Basic use

     once-only /bin/cat README.md

   With PBS

     once-only --pbs /bin/cat README.md

   Using redirects

     echo "/bin/cat README.md > tmp.out" | ./bin/once-only --skip tmp.out

See the README for more examples!

EOB

original_commands = ARGV.join(' ')

gempath = File.dirname(File.dirname(__FILE__))
$: << File.join(gempath,'lib')

VERSION_FILENAME=File.join(gempath,'VERSION')
version = File.new(VERSION_FILENAME).read.chomp

$stderr.print "once-only #{version} (using Ruby #{RUBY_VERSION}) by Pjotr Prins 2013\n"

require 'once-only'

if ARGV.size == 0
  print USAGE
  exit 1
end

def exit_error errval = 1, msg = nil
  $stderr.print msg if msg
  $stderr.print "\nonce-only returned error #{errval}\n"
  exit errval
end

def parse_args(args)
  options = { :skip => [], :skip_regex => [], :skip_glob => [], :include => [] }

  consume = lambda { |args|
    if not args[0]
      # check stdin
      cmd = $stdin.gets
      exit_error(1,"Empty command on STDIN") if cmd == nil
      $stderr.print "Command (STDIN): ",cmd,"\n"
      options[:stdin] = true
      return cmd.split(/\s/)
    end
    return args if File.exist?(args[0]) # reached the executable command
    case args[0]
      when '-d'
        options[:dir] = File.expand_path(args[1])
        consume.call(args[2..-1])
      when '--pbs'
        if args[1] and args[1] =~ /\s+/ # optional PBS argument with spacing
          options[:pbs] = args[1]
          consume.call(args[2..-1])
        else
          options[:pbs] = "''"
          consume.call(args[1..-1])
        end
      when '--skip', '--out'
        options[:skip] << args[1]
        consume.call(args[2..-1])
      when '--skip-exe'
        options[:skip_exe] = true
        consume.call(args[1..-1])
      when '--skip-cli'
        options[:skip_cli] = true
        consume.call(args[1..-1])
      when '--skip-regex'
        options[:skip_regex] << args[1]
        consume.call(args[2..-1])
      when '--skip-glob'
        options[:skip_glob] << args[1]
        consume.call(args[2..-1])
      when '--include', '--in'
        options[:include] << args[1]
        consume.call(args[2..-1])
      when '--copy' 
        options[:copy] = true
        consume.call(args[1..-1])
      when '-h', '--help'
        print USAGE
        exit 1
      when '--debug' 
        options[:debug] = true
        consume.call(args[1..-1])
      when '-v' 
        options[:verbose] = true
        consume.call(args[1..-1])
      when '-q' 
        options[:quiet] = true
        consume.call(args[1..-1])
      when '--dry-run' 
        options[:dry_run] = true
        consume.call(args[1..-1])
      when '--force' 
        options[:force] = true
        consume.call(args[1..-1])
      else
        $stderr.print "Can not parse arguments",args
        exit_error(1)
      end
  }

  return consume.call(args),options
end

args,options = parse_args(ARGV)
once_only_args = OnceOnly::Check.requote([ __FILE__ ] + ( ARGV[0..ARGV.size-args.size-1] ))

if options[:debug]
  print "Full:    "
  p ARGV
  print "Prefix:  "
  p once_only_args
  print "Postfix: "
  p args
  print "Options: "
  p options   
end

# --- Rewrite once-only args for PBS
once_only_args = OnceOnly::Check.drop_pbs_option(once_only_args)
once_only_args = OnceOnly::Check.drop_dir_option(once_only_args)
once_only_command = once_only_args.join(' ')

command = args.join(' ')
command_sorted = args.sort.join(' ')
command_sha1 = OnceOnly::Check::calc_checksum(command_sorted)

# change dir
if options[:dir]
  $stderr.print "Changing dir to ",options[:dir],"\n" if !options[:quiet]
  Dir.chdir options[:dir] 
end

base_dir = Dir.pwd

executable = args[0]
args = args[1..-1] if options[:skip_exe]

file_list = OnceOnly::Check::get_file_list(args)
options[:skip_regex].each { |regex|
  file_list = OnceOnly::Check::filter_file_list(file_list,regex)
}
options[:skip_glob].each { |glob|
  file_list = OnceOnly::Check::filter_file_list_glob(file_list,glob)
}
file_list -= options[:skip] 

OnceOnly::Check::check_files_exist(options[:include])
file_list += options[:include]

checksums = OnceOnly::Check::calc_file_checksums(file_list)
checksums.push ['SHA1',command_sha1,command_sorted] if not options[:skip_cli]

# ---- Create filenames
once_only_filename = OnceOnly::Check::make_once_filename(checksums,File.basename(executable))
$stderr.print "Check file name ",once_only_filename,"\n" if options[:verbose]
error_filename = once_only_filename + '.err'
tag_filename = once_only_filename + '.run'
$stderr.print "Job file exists ",once_only_filename,"!\n" if options[:debug] and File.exist?(once_only_filename)

# ---- Create job name
dirname = File.basename(Dir.pwd).rjust(8,"-") # make sure it is long enough

job_name = (dirname[-5..-1] + once_only_filename.split(/-/).map{|s|s[0..5]}.join).gsub(/[_-]/,'')[0..15]
$stderr.print "Job name ",job_name,"\n" if options[:verbose]

# ---- Create copy destination
if options[:copy]
  copy_dir = base_dir + '/' + File.basename(once_only_filename,".txt") 
end

if options[:force] or not File.exist?(once_only_filename)
  $stderr.print "Running #{command}\n" if not options[:quiet]
  OnceOnly::Check::write_file(tag_filename,checksums)
  if options[:pbs]
    # --- Submit PBS job
    pbs_command = 'echo \'' +
      if options[:stdin]
        'echo "' + command + '"|'+ once_only_command 
      else
        once_only_command + ' ' + command 
      end
    # --- Add PBS part
    pbs_command +=  "'|qsub -N #{job_name} "+options[:pbs]
    pbs_command += ' -d ' + (options[:dir] ? options[:dir] : Dir.pwd) 
 
    $stderr.print("PBS command: ",pbs_command,"\n") if options[:verbose]

    # --- Check if job is already queued in PBS
    qstat = `/usr/bin/qstat`
    if qstat =~ /#{job_name}/
      $stderr.print "Job #{job_name} already in queue!\n"
      exit 0
    end

    if !options[:dry_run]
      if not system(pbs_command) 
        OnceOnly::Check::write_file(error_filename,checksums)
        exit_error($?.exitstatus)
      end
    end
  else
    # --- Run on command line
    if !options[:dry_run]
      success = 
        if options[:copy]
          exit_error(1,"Directory #{copy_dir} already exists!") if File.directory?(copy_dir)
          $stderr.print "Running in directory ",copy_dir
          Dir.mkdir(copy_dir)
          # --- copy files
          # p args
          # p file_list
          clist = args.dup
          file_list.each { | fn | 
            # copy file
            res = `cp #{fn} #{copy_dir}` 
            print res if options[:verbose]
            # replace command
            clist = clist.map { |arg| ( fn == arg ? File.basename(arg) : arg ) }
          }
          p clist if options[:debug]
          command_stripped = clist.join(' ')
          Dir.chdir(copy_dir)
          system_result = system(command_stripped)
          if system_result
            # Copy results back
            Dir.glob(copy_dir+'/*').each { |outfn|
              if clist.index(File.basename(outfn)) > 0
                res = `cp #{outfn} #{base_dir}`
                print res if options[:verbose]
              end
            }
          end
          system_result
        else
          system(command)
        end
      Dir.chdir(base_dir) if options[:copy]
      if not success
        OnceOnly::Check::write_file(error_filename,checksums)
        File.unlink(tag_filename) if File.exist?(tag_filename)
        exit_error($?.exitstatus)
      else
        # --- Success!
        File.unlink(error_filename) if File.exist?(error_filename)
        OnceOnly::Check::write_file(once_only_filename,checksums)
        File.unlink(tag_filename) if File.exist?(tag_filename)
     end
    end
  end
else
  $stderr.print "Inputs unchanged. No need to rerun '#{original_commands}'!\n" if not options[:quiet]
end

exit 0  # success!
